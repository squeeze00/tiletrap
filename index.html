<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Exotic Minesweeper ‚Äî Bright Metallic</title>
<style>
  :root{
    --chrome-hi:#f5f7fa;
    --chrome-mid:#e8edf2;
    --chrome-low:#d8dee6;
    --ink:#151a22;
    --accent:#ff9d00;     /* warm metallic amber */
    --accent-2:#18a0ff;   /* cool neon edge */
    --panel:#ffffffaa;    /* glass panel */
    --line:#cfd7e3;
    --cell-size:48px;
    --board-scale:1;
    --radius:14px;
    --shadow:0 24px 60px rgba(13,18,26,.25), inset 0 0 0 1px rgba(255,255,255,.35);
  }

  /* ===== Bright metallic background (fast) ===== */
  html,body{height:100%}
  body{
    margin:0;
    color:var(--ink);
    font:500 16px/1.25 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    /* layered chrome panels + diagonal brushed lines */
    background:
      radial-gradient(1200px 600px at 15% -10%, rgba(255,217,0,.18), transparent 60%),
      radial-gradient(1100px 800px at 110% 0%, rgba(24,190,255,.18), transparent 60%),
      linear-gradient(180deg, var(--chrome-hi), var(--chrome-mid) 35%, var(--chrome-low)),
      repeating-linear-gradient(135deg, rgba(255,255,255,.0) 0 18px, rgba(255,255,255,.06) 18px 19px);
    overflow:hidden;
  }
  /* moving soft spec highlight */
  body::before{
    content:"";
    position:fixed; inset:-10% -30% auto -30%; height:65%;
    background:linear-gradient(100deg, transparent, rgba(255,255,255,.35), transparent);
    transform:skewY(-8deg);
    filter:blur(10px);
    animation:glint 18s linear infinite;
    pointer-events:none;
  }
  @keyframes glint { to{ transform:translateX(120%) skewY(-8deg); } }

  /* ===== particle sheen (very light) ===== */
  canvas#fx { position:fixed; inset:0; pointer-events:none; mix-blend-mode:soft-light; opacity:.55 }

  /* ===== layout ===== */
  .stage{position:relative; height:100%; display:grid; place-items:start center; padding-top:28px;}
  .parallax{transition:transform .15s ease-out; will-change:transform;}

  /* ===== glass control bar ===== */
  .bar{
    display:flex; align-items:center; gap:12px;
    padding:10px 14px;
    background:linear-gradient(180deg, rgba(255,255,255,.80), rgba(255,255,255,.55));
    backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
    border:1px solid rgba(170,180,195,.7);
    border-radius:12px;
    box-shadow:var(--shadow);
  }
  .chip,.select{
    border:1px solid rgba(170,180,195,.9);
    background:linear-gradient(180deg, #ffffff, #eef3f8);
    color:var(--ink);
    padding:8px 12px;
    border-radius:10px;
    font-weight:700; letter-spacing:.2px;
    display:inline-flex; align-items:center; gap:8px;
    cursor:pointer; user-select:none;
    transition:transform .08s ease, box-shadow .2s ease, border-color .2s;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.8), 0 2px 10px rgba(20,25,35,.12);
  }
  .chip:hover,.select:hover{ transform:translateY(-1px); box-shadow:inset 0 1px 0 rgba(255,255,255,.9), 0 6px 18px rgba(20,25,35,.18); }
  .chip:active{ transform:translateY(0); }
  .chip.accent{
    border-color:#ffb648;
    background:linear-gradient(180deg, #fff3e0, #ffe1b8);
  }
  .select{ appearance:none; padding-right:34px; position:relative; }
  .select-wrap{ position:relative; }
  .select-wrap::after{
    content:"‚ñæ"; position:absolute; right:10px; top:50%; translate:0 -50%;
    color:#6b7687; pointer-events:none; font-weight:900;
  }
  .brand{
    font-weight:900; letter-spacing:.42px; padding:6px 10px; border-radius:10px;
    background:linear-gradient(180deg, #ffffff, #eef3f8);
    border:1px solid rgba(170,180,195,.9);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.85);
  }
  .metric{
    margin-left:8px; padding:6px 10px; border-radius:10px;
    border:1px solid rgba(170,180,195,.8);
    background:linear-gradient(180deg, #ffffff, #eff4f9);
    display:flex; align-items:center; gap:8px; font-weight:900;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.85);
  }
  .dot{ width:10px; aspect-ratio:1; border-radius:999px; background:var(--accent); box-shadow:0 0 14px var(--accent); }

  /* ===== board wrapper keeps controls visible ===== */
  .board-outer{
    position:relative; width:min(92vw, 1100px); height:calc(100svh - 120px);
    margin-top:18px;
    border-radius:var(--radius);
    border:1px solid rgba(170,180,195,.8);
    background:linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.55));
    box-shadow:var(--shadow);
    overflow:auto;
  }

  /* ===== grid ===== */
  .board{
    --s: var(--cell-size);
    display:grid;
    place-content:center;
    gap:1px;
    padding:16px;
    transform:scale(var(--board-scale));
    transform-origin:50% 0%;
    will-change:transform;
  }

  /* ===== cells ===== */
  .cell{
    width:var(--s); height:var(--s);
    display:grid; place-content:center;
    font-weight:900; font-size:calc(var(--s)*.48);
    border-radius:10px;
    color:var(--ink);
    background:
      linear-gradient(180deg, #fefefe, #e9eef5) padding-box,
      linear-gradient(145deg, rgba(255,255,255,.9), rgba(255,255,255,0)) border-box;
    border:1px solid var(--line);
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.9),
      0 1px 0 rgba(0,0,0,.05);
    cursor:pointer;
    transition:filter .06s ease, transform .06s ease, background .2s ease;
    user-select:none;
  }
  .cell.unrevealed:nth-child(even){
    background:
      linear-gradient(180deg, #f8fbff, #e7ecf3) padding-box,
      linear-gradient(145deg, rgba(255,255,255,.9), rgba(255,255,255,0)) border-box;
  }
  .cell:hover{ outline:1.5px solid rgba(24,160,255,.35); filter:brightness(1.05); }
  .cell.revealed{
    background:
      linear-gradient(180deg, #f3f6fb, #e6ecf4) padding-box,
      linear-gradient(145deg, rgba(255,255,255,.7), rgba(255,255,255,0)) border-box;
    color:#1a2330;
    cursor:default;
  }
  .cell.flag::after{ content:"üö©"; filter:drop-shadow(0 0 6px rgba(255,157,0,.6)); }
  .cell.mine.revealed{ background:linear-gradient(180deg, #ffe5e5, #ffd0d0); }
  .cell.mine.revealed::after{ content:"üí£"; filter:drop-shadow(0 0 10px #ff4a4a); }

  /* classic number colors */
  .n1{ color:#1e90ff; } .n2{ color:#14c414; } .n3{ color:#ff3b30; }
  .n4{ color:#2e2bff; } .n5{ color:#b12a17; } .n6{ color:#2bb1b1; }
  .n7{ color:#111; } .n8{ color:#6b7687; }

  /* win accent */
  .win .cell.revealed{ box-shadow:inset 0 0 0 1px rgba(255,255,255,.8), 0 0 16px rgba(24,160,255,.25); }
  .win .board::after{
    content:"";
    position:fixed; inset:0; pointer-events:none;
    background:
      radial-gradient(600px 160px at 50% -80px, rgba(24,160,255,.22), transparent 70%),
      radial-gradient(600px 160px at 50% -120px, rgba(255,157,0,.22), transparent 70%);
    animation:celebrate 1.1s ease-in-out 3;
  }
  @keyframes celebrate{
    0%{opacity:0; transform:translateY(-10px)}
    50%{opacity:1}
    100%{opacity:0; transform:translateY(10px)}
  }

  .hint{position:fixed; inset:auto 0 8px; display:grid; place-items:center; pointer-events:none; font-size:12px; opacity:.55}

  @media (max-width:520px){
    .metric{display:none}
    .bar{gap:8px; padding:8px 10px}
  }
</style>
</head>
<body>
  <canvas id="fx" width="0" height="0" aria-hidden="true"></canvas>

  <div class="stage">
    <div class="parallax">
      <div class="bar">
        <span class="brand">MINESWEEPER</span>

        <span class="select-wrap">
          <select id="difficulty" class="select" title="Difficulty">
            <option value="easy">Easy</option>
            <option value="medium">Medium (40)</option>
            <option value="hard">Hard (100)</option>
          </select>
        </span>

        <button id="zoomIn" class="chip accent" title="Zoom In">Ôºã</button>
        <button id="zoomOut" class="chip" title="Zoom Out">Ôºç</button>
        <button id="reset" class="chip" title="Reset">Reset</button>

        <div class="metric" title="Mines Left">
          <span class="dot"></span><span id="minesLeft">0</span>
        </div>
        <div class="metric" title="Timer">
          ‚è± <span id="timer">0.00s</span>
        </div>
      </div>

      <div class="board-outer" id="boardOuter">
        <div id="board" class="board" role="grid" aria-label="Minesweeper board"></div>
      </div>
    </div>
  </div>

  <div class="hint">Left click: reveal ‚Ä¢ Right click/long-press: flag ‚Ä¢ First click is always safe</div>

<script>
(() => {
  /* ========= Config ========= */
  const DIFFS = {
    easy:   { rows: 9,  cols: 9,  mines: 10 },
    medium: { rows: 16, cols: 16, mines: 40 },
    hard:   { rows: 16, cols: 30, mines: 100 }
  };
  const MIN_ZOOM = 0.6, MAX_ZOOM = 2.0, ZOOM_STEP = 0.15;

  /* ========= State ========= */
  let rows, cols, mineCount;
  let board = [];
  let firstClick = true;
  let zoom = 1;
  let revealedSafe = 0;
  let minesLeft = 0;

  // timer
  let t0 = 0, rafId = 0, running = false;

  // DOM
  const els = {
    diff: document.getElementById('difficulty'),
    board: document.getElementById('board'),
    boardOuter: document.getElementById('boardOuter'),
    timer: document.getElementById('timer'),
    minesLeft: document.getElementById('minesLeft'),
    reset: document.getElementById('reset'),
    zoomIn: document.getElementById('zoomIn'),
    zoomOut: document.getElementById('zoomOut')
  };

  /* ========= Utilities ========= */
  const randInt = (n) => (Math.random() * n) | 0;

  function setZoom(z){
    zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, z));
    document.documentElement.style.setProperty('--board-scale', zoom);
  }

  function startTimer(){
    if (running) return;
    running = true;
    t0 = performance.now();
    const tick = () => {
      if (!running) return;
      const dt = (performance.now() - t0) / 1000;
      els.timer.textContent = dt.toFixed(2) + 's';
      rafId = requestAnimationFrame(tick);
    };
    tick();
  }

  function stopTimer(){
    running = false;
    cancelAnimationFrame(rafId);
  }

  function computeCellSize(r, c){
    const outerW = els.boardOuter.clientWidth - 32;   // padding
    const outerH = els.boardOuter.clientHeight - 32;
    const maxSide = Math.min(outerW, outerH);
    const s = Math.floor(maxSide / Math.max(r, c));
    return Math.min(64, Math.max(36, s)); // bright/large but fits
  }

  function neighbors(r, c){
    const list = [];
    for (let dr=-1; dr<=1; dr++){
      for (let dc=-1; dc<=1; dc++){
        if (dr===0 && dc===0) continue;
        const nr = r+dr, nc = c+dc;
        if (nr>=0 && nr<rows && nc>=0 && nc<cols) list.push([nr,nc]);
      }
    }
    return list;
  }

  function eachCell(fn){
    for (let r=0; r<rows; r++) for (let c=0; c<cols; c++) fn(r,c,board[r][c]);
  }

  function reset(diffKey = els.diff.value){
    const d = DIFFS[diffKey];
    rows = d.rows; cols = d.cols; mineCount = d.mines;
    firstClick = true; revealedSafe = 0; minesLeft = mineCount;
    els.minesLeft.textContent = minesLeft;
    stopTimer(); els.timer.textContent = '0.00s';
    document.body.classList.remove('win');

    const size = computeCellSize(rows, cols);
    document.documentElement.style.setProperty('--cell-size', size + 'px');

    board = Array.from({length:rows}, (_,r)=>(
      Array.from({length:cols}, (_,c)=>({
        r,c, mine:false, rev:false, flag:false, n:0, el:null
      }))
    ));

    els.board.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    els.board.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
    els.board.innerHTML = '';
    const frag = document.createDocumentFragment();

    eachCell((r,c,cell) => {
      const d = document.createElement('div');
      d.className = 'cell unrevealed';
      d.setAttribute('role','gridcell');
      d.dataset.r = r; d.dataset.c = c;
      cell.el = d;
      frag.appendChild(d);
    });
    els.board.appendChild(frag);
    setZoom(1);
  }

  function placeMines(firstR, firstC){
    eachCell((r,c,cell)=>{ cell.mine=false; cell.n=0; });

    let placed = 0;
    const safe = new Set();
    for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++){
      const rr=firstR+dr, cc=firstC+dc;
      if (rr>=0 && rr<rows && cc>=0 && cc<cols) safe.add(rr+','+cc);
    }

    const total = rows*cols, maxAttempts = total*5;
    let attempts = 0;

    while (placed < mineCount && attempts < maxAttempts){
      attempts++;
      const r = randInt(rows), c = randInt(cols);
      const key = r+','+c;
      if (safe.has(key)) continue;
      const cell = board[r][c];
      if (!cell.mine){ cell.mine = true; placed++; }
    }

    eachCell((r,c,cell)=>{
      if (cell.mine) return;
      let n = 0;
      for (const [nr,nc] of neighbors(r,c)) if (board[nr][nc].mine) n++;
      cell.n = n;
    });
  }

  function reveal(r,c){
    const cell = board[r][c];
    if (cell.rev || cell.flag) return;
    if (firstClick){
      placeMines(r,c);
      firstClick = false;
      startTimer();
    }
    if (cell.mine){
      stopTimer();
      eachCell((rr,cc,cl)=>{
        if (cl.mine){ cl.rev=true; cl.el.classList.add('revealed','mine'); }
      });
      return;
    }
    const stack = [[r,c]];
    while (stack.length){
      const [rr,cc] = stack.pop();
      const cur = board[rr][cc];
      if (cur.rev || cur.flag) continue;
      cur.rev = true;
      cur.el.classList.remove('unrevealed');
      cur.el.classList.add('revealed');
      if (cur.n>0){
        cur.el.textContent = cur.n;
        cur.el.classList.add('n'+cur.n);
      } else {
        for (const [nr,nc] of neighbors(rr,cc)){
          const ncell = board[nr][nc];
          if (!ncell.rev && !ncell.flag && !ncell.mine) stack.push([nr,nc]);
        }
      }
      revealedSafe++;
    }
    checkWin();
  }

  function toggleFlag(r,c){
    const cell = board[r][c];
    if (cell.rev) return;
    cell.flag = !cell.flag;
    cell.el.classList.toggle('flag', cell.flag);
    minesLeft += cell.flag ? -1 : 1;
    els.minesLeft.textContent = Math.max(0, minesLeft);
  }

  function checkWin(){
    const safeTotal = rows*cols - mineCount;
    if (revealedSafe >= safeTotal){
      stopTimer();
      document.body.classList.add('win');
      setTimeout(() => reset(els.diff.value), 3500);
    }
  }

  /* ========= Events ========= */
  els.board.addEventListener('click', (e)=>{
    const t = e.target.closest('.cell'); if (!t) return;
    reveal(+t.dataset.r, +t.dataset.c);
  });

  els.board.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    const t = e.target.closest('.cell'); if (!t) return;
    toggleFlag(+t.dataset.r, +t.dataset.c);
  });

  // mobile long press -> flag
  let longPressTimer = 0;
  els.board.addEventListener('touchstart', (e)=>{
    const t = e.target.closest('.cell'); if (!t) return;
    longPressTimer = setTimeout(()=> toggleFlag(+t.dataset.r, +t.dataset.c), 420);
  }, {passive:true});
  ['touchend','touchmove','touchcancel'].forEach(ev=>
    els.board.addEventListener(ev, ()=> clearTimeout(longPressTimer), {passive:true})
  );

  els.diff.addEventListener('change', ()=> reset(els.diff.value));
  els.reset.addEventListener('click', ()=> reset(els.diff.value));
  els.zoomIn.addEventListener('click', ()=> setZoom(zoom + ZOOM_STEP));
  els.zoomOut.addEventListener('click', ()=> setZoom(zoom - ZOOM_STEP));

  // Resize: keep Medium/Hard fitting without scroll (unless zoomed)
  const ro = new ResizeObserver(()=> reset(els.diff.value));
  ro.observe(els.boardOuter);

  // mild parallax
  document.querySelector('.stage').addEventListener('mousemove', (e)=>{
    const {innerWidth:w, innerHeight:h} = window;
    const dx = (e.clientX - w/2)/w, dy=(e.clientY - h/2)/h;
    document.querySelector('.parallax').style.transform =
      `perspective(900px) rotateX(${dy*-3}deg) rotateY(${dx*4}deg)`;
  });

  /* ========= Init ========= */
  reset('easy');

  /* ========= micro tests (console) ========= */
  (function runTests(){
    const assert = (c,m)=> c?console.log('‚úÖ',m):console.error('‚ùå',m);
    reset('easy'); placeMines(4,4);
    let safe=true; for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){const r=4+dr,c=4+dc;if(r>=0&&r<rows&&c>=0&&c<cols&&board[r][c].mine)safe=false;}
    assert(safe,'First click 3√ó3 mine-free');
  })();

  /* ========= Particle sheen ========= */
  const cvs = document.getElementById('fx'), ctx = cvs.getContext('2d');
  function fit(){ cvs.width = innerWidth; cvs.height = innerHeight; }
  fit(); addEventListener('resize', fit);
  const P = Array.from({length:60}, ()=>({
    x: Math.random()*innerWidth,
    y: Math.random()*innerHeight,
    r: Math.random()*1.6 + 0.6,
    vx: (Math.random()-.5)*0.15,
    vy: (Math.random()-.5)*0.15,
    hue: Math.random()<.5 ? 35 : 205
  }));
  (function loop(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    for (const p of P){
      p.x += p.vx; p.y += p.vy;
      if (p.x<0||p.x>cvs.width) p.vx*=-1;
      if (p.y<0||p.y>cvs.height) p.vy*=-1;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fillStyle = `hsla(${p.hue}, 95%, 60%, .25)`;
      ctx.fill();
    }
    requestAnimationFrame(loop);
  })();
})();
</script>
</body>
</html>
